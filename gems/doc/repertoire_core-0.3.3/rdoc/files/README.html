<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Jul 07 00:55:51 +0100 2009</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h3>Repertoire Core README ===</h3>
<p>
The Repertoire Core module collects together tools that 90% of Hyperstudio
projects require. General purpose libraries that provide widely-used
functionality should be added here.
</p>
<p>
Currently the toolkit offers these facilities:
</p>
<p>
(1) User registration, forgotten password, basic profile page (2)
Authorization, using hierarchical user roles (3) Role management: granting,
subscribing, and reviewing (4) Ajax utilities: jquery libraries, form
validation, etc.
</p>
<p>
There&#8216;s no need to use all the tools together: you can cherry-pick
the tools that are useful to your project. Given that most every project
will require Hyperstudio logins, some basic administrative access control,
and ajax widgets, this is the place to look.
</p>
<p>
The role management system (3) is designed for highly-collaborative
projects without a single administrator to control access, and so may be
overkill for some cases. However, it&#8216;s included here since it&#8216;s
a clear extension of the user management and authorization tools.
</p>
<p>
A short overview of each tool follows.
</p>
<h5>User registration and password management =====</h5>
<p>
Adds support for user signup, account activation via email, forgotten
password reset via email, a basic user profile page, and a change password
page.
</p>
<p>
The framework&#8216;s built in session authentication system does a good
job of limiting access to users who have logged in, but provides no UI for
the entire signup and account management process. After you&#8216;ve added
the registration routes to your application, this tool seamlessly adds
these pages to your app.
</p>
<p>
You can customize the look of all of the pages using CSS over-rides, or
write your own views. You can also configure where in the client app your
pages redirect after login, activation, etc., and can add project-specific
info about users to the model via an association.
</p>
<p>
Because the system activates accounts only after confirming a valid email,
it allows your projects a reliable way to confirm users&#8217;
institutional affiliations (i.e. MIT controls password access for anyone
with an email like &#8216;joe@mit.edu&#8217;). This is useful for
site-licensing and as a low-administration way of controlling access.
</p>
<p>
After following the INSTALL directions, the registration and password tool
is configured and ready to use. The user administration API is available
via the console, as well as in your project&#8216;s web pages. See the FAQ
for details on specific issues.
</p>
<h5>Role and authorization control =====</h5>
<p>
Allows your project to control access to portions of its functionality
based on the current user&#8216;s privileges. Each project can define a set
of project- specific roles such as manager, editor, contributor, and guest,
and easily check permissions in the controller. Unlike basic RBAC
(role-based role-based authorization) systems, Repertoire roles are
hierarchical. This keeps role declarations simple and easy to check, and
role membership into concise.
</p>
<p>
As an example, your project might choose a set of core roles: admin,
manager, contributor, and guest. You could then configure your project so
that guests can view materials and comment, but only contributors can
upload new materials. Editors might be able to revise and publish the best
materials to the top level page; and admins could delete materials. Or you
might choose another role arrangement: your project code sets up the roles
and their activities, and the toolkit takes care of checking role logic and
managing users&#8217; associations with roles.
</p>
<p>
To use, you declare your roles in a database migration. Following up the
example above: [*]
</p>
<p>
migration 3, :setup_roles do
</p>
<pre>
  up do
    Role.declare do
      Role[:prj_admin].
        implies(:prj_manager).
        implies(:prj_contributor).
        implies(:prj_guest)
    end
  end
</pre>
<p>
end
</p>
<p>
Then in your controller actions, check the currently logged in user&#8216;s
roles. If the user doesn&#8216;t have sufficient privileges, a Forbidden
(HTTP 403) is raised.
</p>
<p>
class Materials &lt; Application
</p>
<pre>
  ...
  def create(item)
    require_role! :prj_contributor
    ...
  end

  def delete(item)
    require_role! :prj_admin
    ...
  end
  ...
</pre>
<p>
end
</p>
<p>
For simple projects with only a few roles to control administrative access,
it&#8216;s easiest to manage role membership using the console:
</p>
<p>
&gt; joe = User.first(:email =&gt; &#8216;joe@company.com&#8217;) &gt;
Role.grant!(:prj_admin, joe)
</p>
<p>
Finally, so users aren&#8216;t constantly encountering &#8216;Insufficient
privileges&#8217; pages, you can also check roles in your views:
</p>
<p>
&#8230; &lt;% if session.user.has_role?(:contribute) do %&gt;
</p>
<pre>
  &lt;a href=&quot;&lt;%= url(:upload_page) %&gt;&quot;&gt;Contribute new materials&lt;/a&gt;
</pre>
<p>
&lt;% end %&gt;
</p>
<dl>
<dt>*</dt><dd>In real life you should declare role titles before you arrange them into a
hierarchy:

</dd>
</dl>
<pre>
  Role.declare do
    Role[:prj_admin,   &quot;Admin - Foo Project&quot;]
    Role[:prj_manager, &quot;Manager - Foo Project&quot;]
    ...
    Role[:prj_admin].implies(:prj_manager)....
  end

  *Always* namespace your roles by using a project-specific prefix.
</pre>
<h5>Distributed role management: granting and subscribing UI =====</h5>
<p>
The role based authorization system above is fine for projects with just a
few administrative pages. This will cover ~ 70-80% of use cases, where only
a few users need extra access to do tasks like update or delete materials.
In these cases, it&#8216;s simplest to administer role membership by hand
using the console.
</p>
<p>
For projects with more than a few roles, or with many users at differing
levels so access, it would be preferable to distribute administrative tasks
a little. If more privileged users could grant role membership for their
own projects or sub-roles, projects would administer themselves. Taking it
a step further, if users could ask for new privileges through the
interface, it would streamline the experience by letting users join
projects and participate in different capacities at their own initiative -
while still controlling access.
</p>
<p>
For example, in the hierarchy of roles above, it would be best if project
managers could appoint new contributors without the intervention of a
Repertoire sysadmin at the console. Likewise, it would open things up if
members could request contributor access rather than waiting for a manager
to grant it. After quickly reviewing a member&#8216;s request email, the
manager could grant contributor access - or hold off and ask for more info.
</p>
<p>
Repertoire&#8216;s role granting and subscribing system provides this sort
of decentralized and collaborative access. The aim is to foster projects
with lots of user participation and collaboration, while still controlling
access where it&#8216;s necessary. To do this, you can also record who can
grant a given role, and whether it&#8216;s open so other users can
subscribe to it.
</p>
<p>
To model the refinements above, we might use this role declaration.
(&#8216;grants&#8217; is a stronger version of &#8216;implies&#8217; that
means the role can also be granted; &#8216;open&#8217; means the role can
be subscribed to, pending the grantor&#8216;s review.)
</p>
<p>
migration 4, :setup_grantable_roles do
</p>
<pre>
  up do
    Role.declare do
      Role[:prj_admin].                   # closed role
        grants(:prj_manager).             # grantable only by prj_admin
        grants(:prj_contributor).open.    # grantable by prj_manager, or
                                          #   open to subscription, pending
                                          #   prj_manager approval
        implies(:prj_guest).open          # open to subscription - no
                                          #   approval necessary
    end
  end
</pre>
<p>
end
</p>
<p>
And that&#8216;s all! You&#8216;ve just set up a self-administering system
of users and roles, coordinated by the user profile list and notification
emails.
</p>
<p>
There are three basic entry points to the administration pages: (1)
Membership history, which shows the current user&#8216;s role memberships,
and presents a list of potential new roles to subscribe to. (2) Search
users, which lets grantors find specific users, look at their membership
history, and presents a list of potential new roles they&#8216;re qualified
to grant. (3) Review requests, which presents grantors with a list of the
currently open requests they&#8216;re qualified to grant or deny.
</p>
<p>
The interface itself aims to make the process feel like a simple exchange
of messages. The membership history is color-coded, and can be sorted by
request date, role importance, or approval date. The system takes
considerable pains to show only logical options for subscribing and
granting, pruning illogical choices and presenting options for subscription
in a stepwise fashion. Also, whenever in message composition mode, it shows
the past role history relevant to the current role request, grant, or
review.
</p>
<p>
You can reach the role admin functionality from the profile page for each
user, or from their memberships url: <a
href="http://<host>/users/<username>/memberships"><host>/users/<username>/memberships</a>
</p>
<h5>Ajax toolkit and utilities =====</h5>
<p>
The Repertoire Core module is also a central distribution point for other
shared Hyperstudio code - such as jQuery libraries and plugins. For a
current list of 3rd party plugins, see the
&#8216;public/javascripts/lib&#8217; directory.
</p>
<p>
A short description of Hyperstudio-specific ajax plugins follows:
</p>
<ul>
<li>Live form validation plugin (rep.ajax-validate.js)

</li>
</ul>
<p>
This jQuery plugin allows you to quickly add progressive ajax form
validation for <a href="../classes/DataMapper.html">DataMapper</a> models.
Any <a href="../classes/DataMapper.html">DataMapper</a> validation can be
checked directly in the HTML form, as a user fills in fields. Data is
validated using a json web- service on your controller.
</p>
<p>
This has two advantages: (1) you can check database-specific info, like
making sure a login name is unique, or that an association exists. (2) it
keeps all validation code in a single place - the <a
href="../classes/DataMapper.html">DataMapper</a> model. For usage
instructions, see the plugin&#8216;s inline documentation, and look at the
code for user profiles (the validate_user action in app/controllers/users).
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>